package Binary;
/**
 * N개의 정수로 구성된 두 개의 비어 있지 않은 배열 A와 B가 제공됩니다. 이러한 어레이는 N 플랭크를 나타냅니다. 더 정확히 말하면, A[K]가 K-플랭크의 시작이고 B[K]가 K-플랭크의 끝입니다.
 * 그런 다음 M 정수로 구성된 비어 있지 않은 배열 C가 제공됩니다. 이 배열은 Mnails를 나타냅니다. 더 정확히 말하면, C[I]는 I번째 못을 박을 수 있는 위치입니다.
 * A[K] ≤ C[I] ≤ B[K]가 있는 판자(A[K], B[K]는 못이 박힌다고 한다.
 * 모든 판자가 못질될 때까지 사용해야 하는 최소 못 수를 찾는 것이 목표입니다. 즉, 첫 번째 J 네일만 사용한 후 모든 플랭크가 못으로 고정될 수 있는 값 J를 찾아야 합니다. 더 정확히 말하면, 0 ≤ K < N인 모든 플랭크 (A[K], B[K]에 대하여, I ≤ C[I]가 존재해야 한다.
 * 예를 들어, 주어진 배열 A, B는 다음과 같습니다.
 *
 *     A[0] = 1 B[0] = 4
 *     A[1] = 4 B[1] = 5
 *     A[2] = 5 B[2] = 9
 *     A[3] = 8 B[3] = 10
 * [1, 4], [4, 5], [5, 9] 및 [8, 10]의 네 개의 플랭크가 표시됩니다.
 *
 * 지정된 배열 C는 다음과 같습니다.
 *
 *     C[0] = 4
 *     C[1] = 6
 *     C[2] = 7
 *     C[3] = 10
 *     C[4] = 2
 * 다음 못을 사용할 경우:
 *
 * 0이면 플랭크 [1, 4]와 [4, 5]가 모두 못으로 고정됩니다.
 * 0, 1, 플랭크 [1, 4], [4, 5] 및 [5, 9]가 못으로 고정됩니다.
 * 0, 1, 2, 플랭크 [1, 4], [4, 5] 및 [5, 9]가 못으로 고정됩니다.
 * 0, 1, 2, 3 그러면 모든 판자가 못질됩니다.
 * 따라서 4개는 순차적으로 사용되는 모든 판자를 못질할 수 있는 최소 못 개수입니다.
 *
 * 함수 쓰기:
 * 클래스 솔루션 { public int 솔루션(int[] A, int[] B, int[] C);}
 * N개의 정수로 구성된 두 개의 비어 있지 않은 배열 A와 B가 있고 M개의 정수로 구성된 비어 있지 않은 배열 C가 있으면 순차적으로 사용되는 모든 플랭크를 못으로 지정할 수 있는 최소 못 수를 반환합니다.
 * 모든 플랭크를 못으로 고정할 수 없는 경우 함수는 -1을 반환해야 합니다.
 * 예를 들어, 주어진 배열 A, B, C는 다음과 같습니다.
 *
 *     A[0] = 1 B[0] = 4
 *     A[1] = 4 B[1] = 5
 *     A[2] = 5 B[2] = 9
 *     A[3] = 8 B[3] = 10
 *
 *     C[0] = 4
 *     C[1] = 6
 *     C[2] = 7
 *     C[3] = 10
 *     C[4] = 2
 * 위에서 설명한 것처럼 함수는 4를 반환해야 합니다.
 *
 * 다음 가정에 대한 효율적인 알고리즘을 작성합니다.
 *
 * N과 M은 [1] 범위 내의 정수입니다.30,000];
 * 배열 A, B, C의 각 요소는 [1] 범위 내의 정수입니다.2*M];
 * A[K] ≤ B[K].
 * */
public class NailingPlanks {

    public static void main(String[] args){

    }

    public int solution(int[] A, int[] B, int[] C) {
        // write your code in Java SE 8
    }
}
